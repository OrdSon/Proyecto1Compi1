package Parser;
import java_cup.runtime.*;

//1. user code
class Parser;

action code{:

:}

parser code {://código que modifica el comportamiento del parser [sobreescribiendo o creado métodos]    
    public Parser(Lexer lexer){//nuevo constructor
        super(lexer);        
    }    
    public void report_error(String message, Object info) {
        System.out.println("public void report_error");
    }
    
    public void report_fatal_error(String message, Object info) {
        System.out.println("public void report_fatal_error");
    }

    public void syntax_error(Symbol cur_token) {
        System.out.println("El error es el simbolo: " + sym.terminalNames[cur_token.sym]);
        System.out.println(String.format("En la posicion: %d, %d", cur_token.left, cur_token.right));
    }

    public void unrecovered_syntax_error(Symbol cur_token) {
        if (cur_token.sym == sym.EOF) {
            System.out.println("public void unrecoveredsyntax_error");
        }
    }
    protected int error_sync_size(){
        return 1;
    }//
:}//


terminal String INT, STRING,  CHAR, BYTE, FLOAT, LONG, SHORT;
terminal String PUBLIC, PRIVATE, PROTECTED, CLASS, NEW, VOID;
terminal IMPORT ,FINAL, BOOLEAN, RETURN, BREAK;
terminal FOR, WHILE, DO,  SWITCH, CASE, DEFAULT, CONTINUE;
terminal IF,ELSE,STATIC;

terminal MAS, RESTA, MENOS, DIV, MOD ,POR;
terminal AND, OR,AAND,OOR;
terminal CADENA,MENOR,MENORIGUAL,MAYOR;
terminal MAYORIGUAL,NOT;
terminal  String IDENTIFICADOR, DOT, SEMICOLON, COLON,COMA, EQUALS;
terminal  NUMERO,DECIMAL, DOUBLE, OPENPAR, CLOSEPAR, OPENBRACE, CLOSEBRACE;


non terminal String importe, visibilidad, visibilidad_clase, c, clase, body, primitivo, tipo, m, metodo, args;
non terminal sentencia, asignacion, stringS, objetoS;
non terminal intD; 
non terminal expr, expr_list, expr_part;
non terminal inicio, expresion, constructor;
non terminal s2,s3,s10,s11,s13,s14,s15,s20,s21;
non terminal String valor,igualacion,op_logico,expr_logica,signo_logico;
non terminal sentencia_logica, if, while, do_while, while_cicle,switch;
non terminal method_body, cicle_body, for, switch_body,case,case_group,default;
non terminal llamada,primitivoS, expresion_simple, llamada_compleja,params;




precedence left MAS, RESTA;
precedence left POR, DIV, MOD;
precedence left MENOS;
//Gramatica de Imports


start with inicio;

	inicio::= importe inicio
	|c
	;

importe ::= IMPORT s2 SEMICOLON;

s2::=IDENTIFICADOR
	| IDENTIFICADOR DOT s2
	| IDENTIFICADOR DOT POR
	;



body::= asignacion {:"System.out.printl("asignacion body");:} body 
	|expresion {:"System.out.printl("expresion body");:} SEMICOLON body 
	|m {:"System.out.printl("metodo body");:} body 
    |sentencia {:"System.out.printl("sentencia body");:} body
	|constructor {:"System.out.printl("constructor body");:} body
    |visibilidad {:"System.out.printl("visibilidad body");:} asignacion body
    |
	;

visibilidad_clase ::= PUBLIC
	|PRIVATE
	|FINAL
	;

c ::= visibilidad clase
    | clase;

clase ::= CLASS IDENTIFICADOR:n {:System.out.println("Clase llamada: "+n);:} OPENBRACE body CLOSEBRACE;

visibilidad::=visibilidad_clase
	|PROTECTED
	;

primitivo::= BYTE {:System.out.println(" primitivo BYTE");:}
	|SHORT {:System.out.println("primitivo  SHORT");:}
	|INT {:System.out.println("primitivo INT");:}
	|LONG {:System.out.println("primitivo  LONG");:}
	|FLOAT {:System.out.println("primitivo  FLOAT");:}
	|DOUBLE {:System.out.println("primitivo  DOUBLE");:}
	|BOOLEAN {:System.out.println("primitivo  BOOLEAN");:}
	|CHAR {:System.out.println("primitivo  CHAR");:}
	;

tipo::=VOID; 

m ::= visibilidad metodo
	|visibilidad STATIC metodo
    |metodo
	;


	primitivoS ::= primitivo s3;
	stringS ::= STRING   s10 {:System.out.println("STRING");:};
	objetoS ::= IDENTIFICADOR:id s11 {:System.out.println(id);:};

	s3 ::=  IDENTIFICADOR:id {:System.out.println(id);:}
		| IDENTIFICADOR:id COMA s3 {:System.out.println(id);:}
		;
	
	s10 ::=  IDENTIFICADOR:id {:System.out.println(id);:} 
		| IDENTIFICADOR:id COMA s10 {:System.out.println(id);:}
		;
	s11 ::=  IDENTIFICADOR:id {:System.out.println(id);:}
		| IDENTIFICADOR:id COMA s11 {:System.out.println(id);:}
		;

	expresion ::= primitivoS
	| stringS
	| objetoS
	;
    
    expresion_simple::= primitivo:p IDENTIFICADOR:id  {:System.out.println(p+" "+id);:}
            |STRING IDENTIFICADOR:id {:System.out.println(id);:}
            |IDENTIFICADOR:id IDENTIFICADOR:name  {:System.out.println(name+" "+id);:} 
            ;

	sentencia ::= visibilidad expresion SEMICOLON;

args::= expresion_simple 
    |   expresion_simple COMA args
	|
	;

valor ::= CADENA:c {:System.out.println("valor cadena "+c);:}
	|IDENTIFICADOR:c {:System.out.println("valor identificador "+c);:}
	|expr_list:c {:System.out.println("valor lista "+c);:}
	;

asignacion ::=  expresion igualacion SEMICOLON
			| expresion EQUALS NEW IDENTIFICADOR OPENPAR CLOSEPAR SEMICOLON;

igualacion ::= MAS MAS  {:System.out.println("MAS MAS");:}
		|MENOS MENOS {:System.out.println("MENOS MENOS");:}
        |RESTA RESTA {:System.out.println("MENOS MENOS2");:}
		|MAS EQUALS valor
		|MENOS EQUALS valor
		|EQUALS valor
		;

op_logico::= MENOR
	|MENOR EQUALS
	|MAYOR
	|MAYOR EQUALS
	|EQUALS EQUALS
	|NOT EQUALS
	;

signo_logico ::= AND
	|OR
	|AND AND
	|OR OR
	;

sentencia_logica::= valor op_logico valor
        |IDENTIFICADOR;

expr_logica::=sentencia_logica
	|sentencia_logica signo_logico expr_logica
 
	;

if::= IF s13;
	s13 ::= OPENPAR expr_logica CLOSEPAR OPENBRACE method_body CLOSEBRACE
	| OPENPAR expr_logica CLOSEPAR OPENBRACE method_body CLOSEBRACE ELSE if
    | OPENPAR expr_logica CLOSEPAR OPENBRACE method_body CLOSEBRACE ELSE OPENBRACE method_body CLOSEBRACE
    ;



for::= FOR OPENPAR s14 CLOSEPAR OPENBRACE cicle_body CLOSEBRACE;
	s14::= INT IDENTIFICADOR EQUALS NUMERO SEMICOLON IDENTIFICADOR op_logico NUMERO SEMICOLON IDENTIFICADOR igualacion
|INT IDENTIFICADOR EQUALS NUMERO SEMICOLON IDENTIFICADOR op_logico IDENTIFICADOR SEMICOLON IDENTIFICADOR igualacion
	| IDENTIFICADOR IDENTIFICADOR COLON IDENTIFICADOR
	;

while::= WHILE OPENPAR expr_logica CLOSEPAR;
while_cicle::= while OPENBRACE cicle_body CLOSEBRACE;
do_while ::= DO OPENBRACE cicle_body CLOSEBRACE while SEMICOLON;

switch::= SWITCH OPENPAR valor CLOSEPAR OPENBRACE switch_body CLOSEBRACE;


switch_body ::= case_group
	;

case_group::= case case_group
 	|case 
    |default case_group
    |default
 	;

case::= CASE NUMERO COLON method_body BREAK SEMICOLON;
default::= DEFAULT COLON method_body BREAK SEMICOLON;

llamada_compleja ::= IDENTIFICADOR DOT s21;
    s21 ::= llamada
    |IDENTIFICADOR DOT s21
    ;
llamada::=IDENTIFICADOR OPENPAR  params CLOSEPAR SEMICOLON;

params::= valor 
    |valor COMA params;


metodo ::= tipo  s15 {:System.out.println("tipo void");:}
	|IDENTIFICADOR:i  s15 {:System.out.println("tipo"+i);:}
	|STRING s15 {:System.out.println("tipo String");:}
	|primitivo:p s15 {:System.out.println("tipo "+ p);:}
	;

s15::= IDENTIFICADOR:n {:System.out.println("Metodo llamado: "+n);:} OPENPAR args CLOSEPAR OPENBRACE method_body CLOSEBRACE {:System.out.println("Fin metodo");:};

constructor::=visibilidad s20
    |s20
    ;

s20::= IDENTIFICADOR OPENPAR args CLOSEPAR OPENBRACE method_body CLOSEBRACE;

cicle_body::= method_body
	|BREAK SEMICOLON cicle_body
	|CONTINUE SEMICOLON cicle_body
	;


method_body::= llamada {:"System.out.printl("llamada");:} method_body
    |llamada_compleja {:"System.out.printl("llamada compleja");:} method_body
	|switch {:"System.out.printl("switch");:} method_body
	|while_cicle {:"System.out.printl("while");:} method_body
	|do_while {:"System.out.printl("dowhile");:} method_body
	|for {:"System.out.printl("for");:} method_body
	|asignacion {:"System.out.printl("asignacion ");:} method_body
	|sentencia {:"System.out.printl("sentencia");:} method_body
    |expresion SEMICOLON {:"System.out.printl("expresion");:} method_body
	|if {:"System.out.printl("if");:} method_body
    |IDENTIFICADOR igualacion SEMICOLON {:"System.out.printl("identificador");:} method_body
	|RETURN valor SEMICOLON {:"System.out.printl("return valor");:}
	|RETURN SEMICOLON {:"System.out.printl("return");:}
	|
	;



expr_list ::= expr_list expr_part 
	      | 
              expr_part;

expr_part ::= expr:e 
	      {: System.out.println("= " + e); :} 
                          
	      ;

expr      ::= expr:e1 MAS expr:e2    
	      | 
              expr:e1 RESTA expr:e2    
	      | 
              expr:e1 POR expr:e2 
	      | 
              expr:e1 DIV expr:e2 
	      | 
              expr:e1 MOD expr:e2 
	      | 
              NUMERO:n                 
	      {: RESULT = n; :} 
	      | 
              RESTA expr:e             
	      %prec MENOS
	      | 
              OPENPAR expr:e CLOSEPAR     
	 
	      |DECIMAL:d
             {: RESULT = d; :} 
	      ;




